# Chapter 02

## 문제 9. 유쾌한 점퍼(Jolly Jumpers)

n개의 정수(n>0)로 이루어진 수열에 대해 서로 인접해 있는 두 수의 차가 1에서 n-1까지의 값을 모두 가지면 그 수열을 유쾌한 점퍼라고 부른다. 예를 들어 다음과 같은 수열에서

- 1 4 2 3

앞뒤에 있는 숫자 차의 절대 값이 각각 3, 2, 1이므로 이 수열은 유쾌한 점퍼가 된다. 이 정의에 따르면 정수 하나로 된 수열도 유쾌한 점퍼다. 어떤 수열이 유쾌한 점퍼인지 판단할 수 있는 프로그램을 작성하라.

#### >> 입력

각 줄 맨앞에는 3,000 이하의 정수가 있으며 그 뒤에는 수열을 나타내는 n개의 정수가 입력된다.

#### >> 출력

입력된 각 줄에 대해 "Jolly" 또는 "Not jolly"를 한 줄씩 출력한다.

#### >> 결과

<img width="521" alt="스크린샷 2020-01-25 13 50 28" src="https://user-images.githubusercontent.com/50854729/73116443-cbbd6080-3f79-11ea-95ee-f6f13d1f4e66.png">

## 문제 10. 포커 패(Poker Hands)

포커용 카드는 52개의 카드로 이루어진다. 각 카드는 클럽, 다이아몬드, 하트, 스페이드(입력 데이터에서는 각각 C, D, H, S로 표기) 중 한가지 무늬를 가진다. 또한 각 카드는 2에서 10까지, 그리고 잭, 퀸, 킹, 또는 에이스(2, 3, 4, 5, 6, 7, 8, 9, T, J, Q, K, A로 표기)의 값을 갖는다. 점수를 매길 떄 위에 열거한 순서대로 등급이 매겨지며 2가 가장 낮고 에이스가 가장 높다. 무늬는 값에 영향을 끼치지 않는다.

포커 패는 다섯 장의 카드로 구성되며 다음과 같은 순서대로 등급이 매겨진다.

- 하이 카드: 아래에 있는 것 가운데 어떤 범주에도 속하지 않는 패는 그 중 가장 높은 카드의 값에 따라 등급이 매겨진다. 가장 높은 카드의 값이 같으면 그 다음 카드, 그 다음 카드도 같으면 그 다음 카드, 이런 식으로 등급이 매겨진다.
- 원 페어: 다섯 장의 카드 가운데 두 장이 같은 경우. 같은 원 페어끼리 맞붙는 경우에은 더 높은 값ㅇㄹ 가지는 원 페어 패에 더 높은 등급이 매겨진다. 값까지 같은 경우에는 나머지 카드의 값에 의해 더 높은 패가 결정된다ㅣ.
- 투 페어: 두 쌍의 카드가 같은 값을 가지는 경우. 투 페어끼리 맞붙는 경우에는 그 중 더 높은 페어의 값에 의해 더 높은 등급이 매겨진다. 두 쌍의 값이 모두 같으면 남은 카드에 의해 더 높은 패가 결정된다.
- 쓰리 카드: 다섯 장 가운데 세 장이 같은 값을 가지는 경우. 쓰리 카드끼리 맞붙는 경우에는 세 장의 같은 값을 가지는 카드의 값에 의해 더 높은 패가 결정된다.
- 스트레이트: 다섯 장의 카드가 연속적인 값을 가지는 경우. 스트레이트끼리 맞붙을 경우에는 가장 높은 카드에 의해 더 높은 패가 결정된다.
- 플러시: 다섯 장의 카드의 무늬가 모두 같은 경우. 플러시끼리 맞붙을 경우에는 하이 카드의 규칙에 따라서 더 높은 패가 결정된다.
- 풀하우스: 세 장의 카드가 같은 값을 가지고 나머지 두 장의 카드가 같은 값을 가지는 경우. 같은 값을 가지는 세 장의 카드의 우열에 의해 더 높은 패가 결정된다.
- 포카드: 네 장의 카드가 같은 값을 가지는 경우. 포카드끼리 맞붙는 경우에는 네 장의 같은 값을 가지는 카드의 값에 의해 더 높은 패가 결정된다.
- 스트레이트 플러시: 다섯 장의 카드가 무늬가 같으면서 모두 연속적인 값을 가지는 경우. 패에 있는 것 중 가장 높은 카드에 의해 더 높은 패가 결정된다.

몇 쌍의  포커 패를 비교해서 어느 쪽이 이겼는지 아니면 무승부인지 알아내자.

#### >> 입력

입력 파일은 여러 ㅈㄹ로 구성되며 각 줄에느누 열 장의 카드를 나타내는 값이 들어간다. 앞에 있는 다섯 장의 카드는 "Black"이라는 참가자의 카드고 뒤에 있는 다섯 장의 카드는 "White"라는 참가자의 카드다.

#### >> 출력

입력된 각 줄에 대해 다음 중 한가지가 들어있는 행을 출력한다(첫번째는 Black이 이기는 경우,  두 번째는 White가 이기는 경우, 세 번째는 둘이 비기는 경우)

- Black wins.
- White wins.
- Tie.

#### >> 결과

<img width="252" alt="스크린샷 2020-01-27 02 48 04" src="https://user-images.githubusercontent.com/50854729/73139492-d3802080-40b1-11ea-9f40-7914d71aa551.png">

## 문제 11. 동맹 휴업(Hartal)

방글라데시의 정당들은 자신의 세를 과시하기 위해 정기적인 동맹 휴업(파업)을 추진하는데, 이 동맹 휴업은 경제에 상당한 피해를 끼칠 수 있다. 이 문제에서는 각 당을 동맹 휴업 지수(hartal parameter)라고 부르는 h라는 양의 정수로 나타낼 수 있다고 하자. 이 동맹 휴업 지수는 한 동맹 휴업과 다음 동맹 휴업 사이의 기간을 날짜 수로 표시한 값이다.

세 개의 정당이 있다고 생각해보자. 그리고 i번째 당의 동맹 휴업 지수를 h(i)라고 할 때 h(1)=3, h(2)=4, h(3)=8이라고 가정하자. N일(N=14)일 동안의 세 당의 행보를 시뮬레이션하면 다음과 같이 표시할 수 있다. 시뮬레이션은 항상 일요일에 시작하며 금요일이나 토요일에는 동맹 휴업이 없다.

| 요일      | 1(일) | 2(월) | 3(화) | 4(수) | 5(목) | 6(금) | 7(토) | 8(일) | 9(월) | 10(화) | 11(수) | 12(목) | 13(금) | 14(토) |
| --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | ------ |
| 1번 정당  |       |       | X     |       |       | X     |       |       | X     |        |        | X      |        |        |
| 2번 정당  |       |       |       | X     |       |       |       | X     |       |        |        | X      |        |        |
| 3번 정당  |       |       |       |       |       |       |       | X     |       |        |        |        |        |        |
| 동맹 휴업 |       |       | 1     | 2     |       |       |       | 3     | 4     |        |        | 5      |        |        |

이 결과를 보면 14일 동안 정확하게 다섯 번의 동맹 휴업(3, 4, 8, 9, 12일)이 있음을 알 수 있따. 6일은 금요일이기 때문에 동맹 휴업이 일어나지 않는다. 결국 2주 동안 근무 일수로 5일의 동맹 휴업이 실시된다.

몇 정당의 동맹 휴업 지수와, 어떤 정수 N이 주어졌을 때, N일 가운데 동댕 휴업으로 인해 일을 하지않은 근무 일수를 계산하라.

#### >> 입력

입력의 첫번째 줄에는 입력될 테스트 케이스의 개수를 나타내는 하나의 정수 T가 들어있다. 각 테스트 케이스의 첫번째 줄에는 한 개의 정수 N(7<=N<=3,650)이 들어있으며 시뮬레이션을 돌릴 기간(날 수)을 나타낸다. 그 다음 줄에는 정당의 개수를 나타내는 정수 P(1<=P<=100)가 들어간다. 그 다음부터 시작하는 P개의 줄 가운데 i번째 줄(1<=i<=P)에는 i번째 정당의 동맹 휴업 지수를 나타내는 양의 정수 h(i)(7의 배수는 아님)가 들어있다.

#### >> 출력

각 테스트 케이스에 대해 손실된 근무 일수를 한 줄에 하나씩 출력한다.

#### >> 결과

<img width="342" alt="스크린샷 2020-01-28 02 57 28" src="https://user-images.githubusercontent.com/50854729/73200797-dd218b00-417a-11ea-93a7-c7fa88d22de9.png">

## 문제 12. 암호 깨기(Crypt Kicker)

텍스트를 암호화하는 방법 중에 보안상 취약하긴 하지만 흔하게 쓰이는 방법으로 알파벳 글자를 다른 글자로 돌리는 방법이 있다. 즉 알파벳의 각 글자를 다른 글자로 치환한다. 암호화된 것을 다시 원래대로 되돌릴 수 있으려면 두 개의 서로 다른 글자가 같은 글자로 치환되지 않아야 한다.

암호화된 텍스트가 한 줄 이상 입력되는데, 각 줄마다 서로 다른 치환 방법이 적용된다고 가정하자. 암호화 이전의 텍스트에 있는 단어는 모두 주어진 사전에 들어있는 단어라고 가정하고, 암호화된 텍스트를 해독하여 원래 텍스트를 알아내자.

#### >> 입력

입력은 한 개의 정수 n이 들어있는 행으로 시작되며 그 다음 줄부터는 한 줄에 하나씩 n개의 소무자로 쓰인 단어들이 알파벳 순으로 입력된다. 이 n개의 단어들은 복호화된 텍스트에 들어갈 수 있는 단어로 구성된 사전이다. 사전 뒤에는 몇 줄의 텍스트가 입력된다. 각 줄은 앞에서 설명했던 방법에 따라 암호화된다.

사전에 들어갈 수 있는 단어의 개수는 1,000개를 넘지 않는다. 단어의 길이는 16글자를 넘지 않는다. 암호화된 텍스트에는 소무자와 스페이스만 들어가며 한 줄의 길이는 80글자를 넘어가지 않는다.

#### >> 출력

각 줄을 복호화하여 표준 출력으로 출력한다. 여러 문장으로 복호화될 수 있다면 그 중 아무 결과나 출력하면 된다. 가능한 풀이가 없다면 알파벳 모든 문자를 아스테리스크( <b>*</b> )로 바꾸면 된다.

#### >> 결과

<img width="365" alt="스크린샷 2020-01-29 06 52 10" src="https://user-images.githubusercontent.com/50854729/73310149-03bcf000-4267-11ea-8436-ff53d389315b.png">

## 문제 13. 쌓아 올리기(Stack `em Up)

빅 시티(Big City)에는 카지노가 여러 개 있다. 그 중 한 카지노에 있는 딜러가 속임수를 쓴다. 그녀는 몇 가지 섞는 법을 완벽하게 익혔는데 그 카드 섞는 법을 사용하면 언제든지 카드를 마음대로 재배치할 수 있다. 간단한 예로 "밑장" 섞기를 들 수 있는데, 맨 아래 있는 카드를 꺼내서 맨 위로 올려놓는 방법이다. 그 딜러는 이런 다양한 섞기 방법을 조합해서 원하는 순서대로 카드를 쌓아 올릴 수 있다.

카지노의 보안 관리자가 그 딜러를 감시하기 위해 당신을 고용했다. 딜러가 섞은 모든 카드 순서가 주어지며 사용된 섞기 방법도 제공된다. 이런 정보가 주어졌을 때 몇 번의 섞기 작업이 진행된 후의 카드 순서를 예측해야 한다.

카드 한벌은 52개의 카드로 구성되며 네 개의 무늬마다 13장의 카드가 있다. 카드의 값(숫자)은 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace 중 하나다. 그리고 무늬는 Clubs, Diamonds, Hearts, Spaces, 가운데 하나다. 각 카드는 <값> of <무늬>와 같은 식으로 표현할 수 있다. 관례에 따라 새 카드는 우선 무늬를 기준으로 알파벳 순으로, 그리고 위에 나와있는 값 순서대로 정렬된다.

#### >> 입력

입력은 테스트 케이스의 개수를 나타내는 숫자 하나만 들어있는 줄로 시작되며 그 다음 줄은 빈 줄이다. 또한 두 개의 연속된 테스트 케이스 사이에도 빈 줄이 하나씩 들어간다.

각 케잏스는 딜러가 알고 있는 섞기 방법의 개수인 100 이하의 정수 n으로 시작된다. 그 다음 줄에는 52개의 정수가 n세트 나오는데 각 세트에는 1에서 52까지의 모든 정수가 들어있다. 52개의 정수로 구성된 각 세트 내에서 j위치에 i가 있다는 것은 패에서 i번째 카드를 j번째 위치로 이동시킨다는 것을 의미한다.

그 뒤에는 각각 1 이상 n 이하의 정수 k가 들어있는 행이 여러 개 뒤따른다. 입력된 정수 k는 딜러가 k번째 섞기 방법을 썼다는 것을 나타낸다.

#### >> 출력

각 테스트 케이스에 대해 딜러가 위에 기술되어 있는 대로 정렬된 새로운 패를 가지고 시작한다고 가정하고 섞기가 모두 끝난 후에 새로운 순서에 따라서 카드의 이름을 출력한다. 두 개의 서로 다른 케이스에 대한 출력 결과는 빈 줄로 구분한다.

#### >> 결과

<img width="1039" alt="스크린샷 2020-01-30 05 04 53" src="https://user-images.githubusercontent.com/50854729/73393087-6cb36f00-431e-11ea-9bca-67b3e95b70c4.png">
<img width="1094" alt="스크린샷 2020-01-30 05 05 15" src="https://user-images.githubusercontent.com/50854729/73393117-789f3100-431e-11ea-9b04-6afda79e1cfa.png">