# Chapter 02

## 문제 9. 유쾌한 점퍼(Jolly Jumpers)

n개의 정수(n>0)로 이루어진 수열에 대해 서로 인접해 있는 두 수의 차가 1에서 n-1까지의 값을 모두 가지면 그 수열을 유쾌한 점퍼라고 부른다. 예를 들어 다음과 같은 수열에서

- 1 4 2 3

앞뒤에 있는 숫자 차의 절대 값이 각각 3, 2, 1이므로 이 수열은 유쾌한 점퍼가 된다. 이 정의에 따르면 정수 하나로 된 수열도 유쾌한 점퍼다. 어떤 수열이 유쾌한 점퍼인지 판단할 수 있는 프로그램을 작성하라.

#### >> 입력

각 줄 맨앞에는 3,000 이하의 정수가 있으며 그 뒤에는 수열을 나타내는 n개의 정수가 입력된다.

#### >> 출력

입력된 각 줄에 대해 "Jolly" 또는 "Not jolly"를 한 줄씩 출력한다.

#### >> 결과

<img width="521" alt="스크린샷 2020-01-25 13 50 28" src="https://user-images.githubusercontent.com/50854729/73116443-cbbd6080-3f79-11ea-95ee-f6f13d1f4e66.png">

<hr>

## 문제 10. 포커 패(Poker Hands)

포커용 카드는 52개의 카드로 이루어진다. 각 카드는 클럽, 다이아몬드, 하트, 스페이드(입력 데이터에서는 각각 C, D, H, S로 표기) 중 한가지 무늬를 가진다. 또한 각 카드는 2에서 10까지, 그리고 잭, 퀸, 킹, 또는 에이스(2, 3, 4, 5, 6, 7, 8, 9, T, J, Q, K, A로 표기)의 값을 갖는다. 점수를 매길 떄 위에 열거한 순서대로 등급이 매겨지며 2가 가장 낮고 에이스가 가장 높다. 무늬는 값에 영향을 끼치지 않는다.

포커 패는 다섯 장의 카드로 구성되며 다음과 같은 순서대로 등급이 매겨진다.

- 하이 카드: 아래에 있는 것 가운데 어떤 범주에도 속하지 않는 패는 그 중 가장 높은 카드의 값에 따라 등급이 매겨진다. 가장 높은 카드의 값이 같으면 그 다음 카드, 그 다음 카드도 같으면 그 다음 카드, 이런 식으로 등급이 매겨진다.
- 원 페어: 다섯 장의 카드 가운데 두 장이 같은 경우. 같은 원 페어끼리 맞붙는 경우에은 더 높은 값ㅇㄹ 가지는 원 페어 패에 더 높은 등급이 매겨진다. 값까지 같은 경우에는 나머지 카드의 값에 의해 더 높은 패가 결정된다ㅣ.
- 투 페어: 두 쌍의 카드가 같은 값을 가지는 경우. 투 페어끼리 맞붙는 경우에는 그 중 더 높은 페어의 값에 의해 더 높은 등급이 매겨진다. 두 쌍의 값이 모두 같으면 남은 카드에 의해 더 높은 패가 결정된다.
- 쓰리 카드: 다섯 장 가운데 세 장이 같은 값을 가지는 경우. 쓰리 카드끼리 맞붙는 경우에는 세 장의 같은 값을 가지는 카드의 값에 의해 더 높은 패가 결정된다.
- 스트레이트: 다섯 장의 카드가 연속적인 값을 가지는 경우. 스트레이트끼리 맞붙을 경우에는 가장 높은 카드에 의해 더 높은 패가 결정된다.
- 플러시: 다섯 장의 카드의 무늬가 모두 같은 경우. 플러시끼리 맞붙을 경우에는 하이 카드의 규칙에 따라서 더 높은 패가 결정된다.
- 풀하우스: 세 장의 카드가 같은 값을 가지고 나머지 두 장의 카드가 같은 값을 가지는 경우. 같은 값을 가지는 세 장의 카드의 우열에 의해 더 높은 패가 결정된다.
- 포카드: 네 장의 카드가 같은 값을 가지는 경우. 포카드끼리 맞붙는 경우에는 네 장의 같은 값을 가지는 카드의 값에 의해 더 높은 패가 결정된다.
- 스트레이트 플러시: 다섯 장의 카드가 무늬가 같으면서 모두 연속적인 값을 가지는 경우. 패에 있는 것 중 가장 높은 카드에 의해 더 높은 패가 결정된다.

몇 쌍의  포커 패를 비교해서 어느 쪽이 이겼는지 아니면 무승부인지 알아내자.

#### >> 입력

입력 파일은 여러 ㅈㄹ로 구성되며 각 줄에느누 열 장의 카드를 나타내는 값이 들어간다. 앞에 있는 다섯 장의 카드는 "Black"이라는 참가자의 카드고 뒤에 있는 다섯 장의 카드는 "White"라는 참가자의 카드다.

#### >> 출력

입력된 각 줄에 대해 다음 중 한가지가 들어있는 행을 출력한다(첫번째는 Black이 이기는 경우,  두 번째는 White가 이기는 경우, 세 번째는 둘이 비기는 경우)

- Black wins.
- White wins.
- Tie.

#### >> 결과

<img width="252" alt="스크린샷 2020-01-27 02 48 04" src="https://user-images.githubusercontent.com/50854729/73139492-d3802080-40b1-11ea-9f40-7914d71aa551.png">

<hr>

## 문제 11. 동맹 휴업(Hartal)

방글라데시의 정당들은 자신의 세를 과시하기 위해 정기적인 동맹 휴업(파업)을 추진하는데, 이 동맹 휴업은 경제에 상당한 피해를 끼칠 수 있다. 이 문제에서는 각 당을 동맹 휴업 지수(hartal parameter)라고 부르는 h라는 양의 정수로 나타낼 수 있다고 하자. 이 동맹 휴업 지수는 한 동맹 휴업과 다음 동맹 휴업 사이의 기간을 날짜 수로 표시한 값이다.

세 개의 정당이 있다고 생각해보자. 그리고 i번째 당의 동맹 휴업 지수를 h(i)라고 할 때 h(1)=3, h(2)=4, h(3)=8이라고 가정하자. N일(N=14)일 동안의 세 당의 행보를 시뮬레이션하면 다음과 같이 표시할 수 있다. 시뮬레이션은 항상 일요일에 시작하며 금요일이나 토요일에는 동맹 휴업이 없다.

| 요일      | 1(일) | 2(월) | 3(화) | 4(수) | 5(목) | 6(금) | 7(토) | 8(일) | 9(월) | 10(화) | 11(수) | 12(목) | 13(금) | 14(토) |
| --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | ------ |
| 1번 정당  |       |       | X     |       |       | X     |       |       | X     |        |        | X      |        |        |
| 2번 정당  |       |       |       | X     |       |       |       | X     |       |        |        | X      |        |        |
| 3번 정당  |       |       |       |       |       |       |       | X     |       |        |        |        |        |        |
| 동맹 휴업 |       |       | 1     | 2     |       |       |       | 3     | 4     |        |        | 5      |        |        |

이 결과를 보면 14일 동안 정확하게 다섯 번의 동맹 휴업(3, 4, 8, 9, 12일)이 있음을 알 수 있따. 6일은 금요일이기 때문에 동맹 휴업이 일어나지 않는다. 결국 2주 동안 근무 일수로 5일의 동맹 휴업이 실시된다.

몇 정당의 동맹 휴업 지수와, 어떤 정수 N이 주어졌을 때, N일 가운데 동댕 휴업으로 인해 일을 하지않은 근무 일수를 계산하라.

#### >> 입력

입력의 첫번째 줄에는 입력될 테스트 케이스의 개수를 나타내는 하나의 정수 T가 들어있다. 각 테스트 케이스의 첫번째 줄에는 한 개의 정수 N(7<=N<=3,650)이 들어있으며 시뮬레이션을 돌릴 기간(날 수)을 나타낸다. 그 다음 줄에는 정당의 개수를 나타내는 정수 P(1<=P<=100)가 들어간다. 그 다음부터 시작하는 P개의 줄 가운데 i번째 줄(1<=i<=P)에는 i번째 정당의 동맹 휴업 지수를 나타내는 양의 정수 h(i)(7의 배수는 아님)가 들어있다.

#### >> 출력

각 테스트 케이스에 대해 손실된 근무 일수를 한 줄에 하나씩 출력한다.

#### >> 결과

<img width="342" alt="스크린샷 2020-01-28 02 57 28" src="https://user-images.githubusercontent.com/50854729/73200797-dd218b00-417a-11ea-93a7-c7fa88d22de9.png">

 <hr>

## 문제 12. 암호 깨기(Crypt Kicker)

텍스트를 암호화하는 방법 중에 보안상 취약하긴 하지만 흔하게 쓰이는 방법으로 알파벳 글자를 다른 글자로 돌리는 방법이 있다. 즉 알파벳의 각 글자를 다른 글자로 치환한다. 암호화된 것을 다시 원래대로 되돌릴 수 있으려면 두 개의 서로 다른 글자가 같은 글자로 치환되지 않아야 한다.

암호화된 텍스트가 한 줄 이상 입력되는데, 각 줄마다 서로 다른 치환 방법이 적용된다고 가정하자. 암호화 이전의 텍스트에 있는 단어는 모두 주어진 사전에 들어있는 단어라고 가정하고, 암호화된 텍스트를 해독하여 원래 텍스트를 알아내자.

#### >> 입력

입력은 한 개의 정수 n이 들어있는 행으로 시작되며 그 다음 줄부터는 한 줄에 하나씩 n개의 소무자로 쓰인 단어들이 알파벳 순으로 입력된다. 이 n개의 단어들은 복호화된 텍스트에 들어갈 수 있는 단어로 구성된 사전이다. 사전 뒤에는 몇 줄의 텍스트가 입력된다. 각 줄은 앞에서 설명했던 방법에 따라 암호화된다.

사전에 들어갈 수 있는 단어의 개수는 1,000개를 넘지 않는다. 단어의 길이는 16글자를 넘지 않는다. 암호화된 텍스트에는 소무자와 스페이스만 들어가며 한 줄의 길이는 80글자를 넘어가지 않는다.

#### >> 출력

각 줄을 복호화하여 표준 출력으로 출력한다. 여러 문장으로 복호화될 수 있다면 그 중 아무 결과나 출력하면 된다. 가능한 풀이가 없다면 알파벳 모든 문자를 아스테리스크( <b>*</b> )로 바꾸면 된다.

#### >> 결과

<img width="365" alt="스크린샷 2020-01-29 06 52 10" src="https://user-images.githubusercontent.com/50854729/73310149-03bcf000-4267-11ea-8436-ff53d389315b.png">

 <hr>

## 문제 13. 쌓아 올리기(Stack `em Up)

빅 시티(Big City)에는 카지노가 여러 개 있다. 그 중 한 카지노에 있는 딜러가 속임수를 쓴다. 그녀는 몇 가지 섞는 법을 완벽하게 익혔는데 그 카드 섞는 법을 사용하면 언제든지 카드를 마음대로 재배치할 수 있다. 간단한 예로 "밑장" 섞기를 들 수 있는데, 맨 아래 있는 카드를 꺼내서 맨 위로 올려놓는 방법이다. 그 딜러는 이런 다양한 섞기 방법을 조합해서 원하는 순서대로 카드를 쌓아 올릴 수 있다.

카지노의 보안 관리자가 그 딜러를 감시하기 위해 당신을 고용했다. 딜러가 섞은 모든 카드 순서가 주어지며 사용된 섞기 방법도 제공된다. 이런 정보가 주어졌을 때 몇 번의 섞기 작업이 진행된 후의 카드 순서를 예측해야 한다.

카드 한벌은 52개의 카드로 구성되며 네 개의 무늬마다 13장의 카드가 있다. 카드의 값(숫자)은 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace 중 하나다. 그리고 무늬는 Clubs, Diamonds, Hearts, Spaces, 가운데 하나다. 각 카드는 <값> of <무늬>와 같은 식으로 표현할 수 있다. 관례에 따라 새 카드는 우선 무늬를 기준으로 알파벳 순으로, 그리고 위에 나와있는 값 순서대로 정렬된다.

#### >> 입력

입력은 테스트 케이스의 개수를 나타내는 숫자 하나만 들어있는 줄로 시작되며 그 다음 줄은 빈 줄이다. 또한 두 개의 연속된 테스트 케이스 사이에도 빈 줄이 하나씩 들어간다.

각 케잏스는 딜러가 알고 있는 섞기 방법의 개수인 100 이하의 정수 n으로 시작된다. 그 다음 줄에는 52개의 정수가 n세트 나오는데 각 세트에는 1에서 52까지의 모든 정수가 들어있다. 52개의 정수로 구성된 각 세트 내에서 j위치에 i가 있다는 것은 패에서 i번째 카드를 j번째 위치로 이동시킨다는 것을 의미한다.

그 뒤에는 각각 1 이상 n 이하의 정수 k가 들어있는 행이 여러 개 뒤따른다. 입력된 정수 k는 딜러가 k번째 섞기 방법을 썼다는 것을 나타낸다.

#### >> 출력

각 테스트 케이스에 대해 딜러가 위에 기술되어 있는 대로 정렬된 새로운 패를 가지고 시작한다고 가정하고 섞기가 모두 끝난 후에 새로운 순서에 따라서 카드의 이름을 출력한다. 두 개의 서로 다른 케이스에 대한 출력 결과는 빈 줄로 구분한다.

#### >> 결과

<img width="1039" alt="스크린샷 2020-01-30 05 04 53" src="https://user-images.githubusercontent.com/50854729/73393087-6cb36f00-431e-11ea-9bca-67b3e95b70c4.png">
<img width="1094" alt="스크린샷 2020-01-30 05 05 15" src="https://user-images.githubusercontent.com/50854729/73393117-789f3100-431e-11ea-9b04-6afda79e1cfa.png">

<hr>

## 문제 14. 에르되시 수(Erdös Numbers)

헝가리 출신의 수학자 폴 에르되시(Paul Erdös, 1913-1996)는 20세기의 가장 유명한 수학자 가운데 하나로 꼽힌다. 에르되시와 함께 논문을 쓴 경험이 있는 수학자들도 존경을 받을 정도니 그의 명성을 짐작할 수 있을 것이다. 

하지만 불행하게도 모든 사람들이 그와 함께 논문을 쓸 기회를 얻을 수 있는 것은 아니었기 때문에 에르되시와 함께 논문을 썼던 사람과 논문을 같이 쓰는 정도로 만족해야 했다. 이런 이유로 인해 에르되시 수라는 것이 생겼다. 에르되시 와 함께 논문을 쓴 사람의 에르되시 수는 1이다. 에르되시와 직접 함께 논문을 쓰진 않았지만 에르되시 수가 1인 사람과 함께 논문을 쓴 적이 있는 사람의 에르되시 수는 2이다.

주어진 논문과 눈문 저자를 바탕으로 에르되시 수를 계산하는 프로그램을 만들어야 한다.

#### >> 입력

입력의 첫번째 행에는 시나리오 개수가 들어있다. 각 시나리오는 논문 데이터베이스와 이름의 목록으로 구성된다. 각 시나리오의 첫번째 줄에는 P와 N이라는 자연수 두 개가 입력된다. 그 다음 줄에는 논문 데이터베이스가 입력되며 각 논문마다 한 줄씩 저자에 대한 정보가 입력된다. 각 논문에 대한 정보는 다음과 같은 식으로 기술된다.

<center><b>Smith, M.N., Martin, G., Erodes, P.: Newtonian forms of prime factors matrices</b></center>
ö같은 움라우트는 편의상 'o'로 표기한다. P개의 논문 정보 밑에는 각각 하나씩의 이름이 들어있는 N개의 행이 입력된다. 이름은 다음과 같은 형식으로 입력된다.

<center><b>Martin, G.</b></center>
#### >> 출력

각 시나리오에 대해 "Scenario <i>i</i>"(i는 시나리오 번호)라는 내용이 들어있는 행을 우선 출력한다. 그 다음 줄부터는 입력된 모든 이름에 대해 이름과 에르되시 수를 출력한다. 저자의 이름은 입력된 순서대로 출력된다. 에르되시 수는 시나리오에 들어있는 논문 데이터베이스를 기반으로 계산한다. 데이터베이스에 있는 논문으로 볼 때 에르되시와 전혀 관계가 없는 저자들의 에르되시 수는 "infinity"로 출력한다.

#### >> 결과

<img width="548" alt="스크린샷 2020-01-31 05 24 20" src="https://user-images.githubusercontent.com/50854729/73487498-773b3a80-43ea-11ea-8d52-7a635b4e8696.png">

<hr>

## 문제 15. 경시 대회 점수판(Contest Scoreboard)

ACM ICPC에 출전하고 싶다면 점수 계산법을 알아야 한다. 경시 대회에 참가한 팀의 순위는 우선  푼 문제의 개수가 많은 순으로,  그 다음으로는 시간 벌점(penalty time)이 적은 순으로 매겨진다. 이 둘을 모두 고려했는 데도 동점 팀이 둘 이상이면 팀 멤버 수가 적은 쪽이 더 높은  순위를 차지할 수 있다.

제출된 풀이 가운데 정답으로 판정받은 것이 하나라도 있으면 그 문제는 해결된 것으로 인정된다. 시간 벌점은 해당 문제에 대한 첫번째 정답이 제출될 때까지 걸린 시간으로 계산되며 정답이 나오기 전까지 제출된 오답이 있으면 한 개에 20분씩의 시간 벌점이 추가된다. 풀리지 않은 문제에 대해서는 시간 벌점이 전혀 적용되지 않는다.

#### >> 입력

첫 줄에는 케이스의 개수를 나타내는 양의 정수 한 개가 들어있다. 그 다음 줄은 빈 줄이며 서로 다른 입력 사이에도 빈 줄이 하나 들어간다.

각 입력은 심사 큐의 스냅샷으로 구성되는데, 여기에는 1번부터 9번까지의 문제를 푸는 1번부터 100번까지의 경시 대회 참가 팀으로부터 입력된 내용이 들어있다. 각 줄은 세 개의 수와 경시 대회 문제 시간 L형식의 글자 하나로 구성된다. L은 C, I, R, U 또는 E라는 값을 가질 수 있는데 이 글자들은 각각 Correct(정답), Incorrect(오답), clarification Request(확인 용청), Unjudge(미심사), Erroneous submission(제출 오류)을 의미한다. 마지막 세 개의 케이스는 점수에 영향을 미치지 않는다. 입력은 제출된 순서대로 입력된다.

#### >> 출력

각  테스트 케이스에 대해 앞에서 설명한 순서에 의해 정렬된 점수표가 출력된다. 출력되는 각 줄에는 참가 팀 번호, 그 팀이 푼 문제 개수, 누적된 시간 벌점이 출력된다. 모든 경시 대회 참가 팀이 풀이를 제출하는 것은 아니므로 실제로 풀이를 제출한 팀의 결과만 표시한다. 그리고 두 개의 서로 다른 케이스에 대한 출력은 빈 줄로 구분한다.

#### >> 결과

<img width="354" alt="스크린샷 2020-02-03 04 31 43" src="https://user-images.githubusercontent.com/50854729/73613977-4ce1bb00-463e-11ea-85e4-86c2cdc06189.png">

<hr>

## 문제 16. 야찌(Yahtzee)

야찌 게임은 다섯 개의 주사위를 써서 하는 게임으로, 13 라운드에 걸쳐서 주사위를 던지는 게임이다. 스코어 카드에는 13개의 카테고리가 있다. 각 라운드에서는 게임 참가자가 선택한 카테고리에 의해 점수를 딸 수 있는데, 이때 각 카테고리는 한 게임에 한 번만 쓸 수 있다. 13개의 카테고리에서는 다음과 같은 식으로 점수를 딴다.

- 1 - 모든 1들의 합
- 2 - 모든 2들의 함
- 3 - 모든 3들의 합
- 4 - 모든 4들의 합
- 5 - 모든 5들의 합
- 6 - 모든 6들의 합
- 찬스 - 모든 숫자의 합
- 같은 숫자 세 개 - 적어도 세 개가 같은 숫자일 때,  모든 숫자의 합
- 같은 숫자 네 개 - 적어도 네 개가 같은 숫자일 때,  모든 숫자의 합
- 같은 숫자 다섯 개 - 다섯 개 모두 같은 숫자일 떄, 50점
- 쇼트 스트레이트 - 네 개가 연속된 숫자일 때(1, 2, 3, 4 또는 2, 3, 4, 5, 또는 3, 4, 5, 6), 25점
- 롱 스트레이트 - 다섯 개가 연속된 숫자일 때(1, 2, 3, 4, 5 또는 2, 3, 4, 5, 6), 35점
- 풀 하우스 - 세 개가 같은 숫자이고 나머지 두 개가 같은 숫자일 떄(예를 들면 2, 2, 5, 5, 5), 40점

마지막 여섯 개의 카테고리는 조건이 만족되지 않으면 0점으로 처리된다.

이 게임의 총점은 13개의 카테고리 각각의 점수를 모두 더한 점수며 첫번째부터 여섯 번째까지의 카테고리 총점이 63점 이상이면 보너스 점수 35점이 추가된다.

여러 라운드가 주어졌을 때 가능한 최고 점수를 계산하라.

#### >> 입력

각 줄에는 1 이상 6 이하의 정수가 다섯 개 있으며 이는 각 라운드에 나온 주사위 다섯 개의 숫자를 나타낸다. 매 게임마다 13줄이 입력되며 입력 데이터에 들어있는 게임 횟수에는 제한이 없다.

#### >> 출력

한 게임당 한 줄에 15개의 숫자를 출력한다. 15개의 숫자는 각 카테고리별 점수(위에 나와있는 순서대로)와 보너스 점수(0 또는 35), 그리고 총점이다. 여러 방식으로 카테고리를 적용했을 때 같은 점수가 나오면 그 중 아무 결과나 출력해도 된다.

#### >> 결과

<img width="500" alt="스크린샷 2020-02-06 07 39 23" src="https://user-images.githubusercontent.com/50854729/73889890-06959180-48b4-11ea-8b23-4c6c4f7fef18.png">