# Chapter 01

## 문제 1. 3n+1.py

어떤 수열을 만들어내는 다음과 같은 알고리즘을 생각해보자. 어떤 정수 n에서 시작해 n이 짝수면 2로 나누고, 홀수면 3을 곱한 다음 1을 더한다. 이렇게 해서 새로 만들어진 숫자를 n으로 놓고 n=1이 될 때까지 같은 작업을 계속 반복한다. 예를 들어, n=22이면 다음과 같은 수열이 만들어진다.

22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1

아직 증명되진 않았지만 모든 정수 n에 대해 이 알고리즘을 적용시키면 결국에는 n=1에 이르게 되는 것으로 추측된다. 그리고 이 가설은 적어도 1,000,000까지의 정수에 대해서는 참이다.

n이라는 값이 입력되었을 때 1이 나올 때까지 만들어진 수의 개수(1 포함)를 n의 사이클 길이(cycle-length)라고 한다. 위에 있는 수열을 예로 들면 22의 사이클 길이는 16이다. i와 j라는 두 개의 수가 주어졌을 떄 i와 j사이의 모든 수(i,j 포함)에 대해 최대 사이클 길이를 구하라.

#### >> 입력

입력은 일련의 정수쌍 i와 j로 구성되며 한 줄에 한 쌍의 수가 입력된다. 모든 정수는 1,000,000보다 작고 0보다 크다.

#### >> 출력

각 정수쌍 i와 j에 대해 i와 j를 입력된 순서대로 출력하고 i와 j 사이(i,j 포함)의 최대 사이클 길이를 출력한다. 이 세 수는 각각 하나씩의 스페이스로 구분되어야 하며 세 수가 모든 한 줄에 출력되어야 하고 입력된 각 줄마다 한 줄씩 출력해야 한다.

#### >> 결과

<img width="295" alt="스크린샷 2020-01-16 01 59 40" src="https://user-images.githubusercontent.com/50854729/72454335-ff72ea80-3803-11ea-850e-2a7ad3d15234.png">

<hr>

## 문제 2. 지뢰 찾기(Minesweeper)

지뢰 찾기를 해본 적이 있는 독자들이 많을 것이다. 이름은 잘 기억나지 않지만 어떤 운영체제에 이 작고 귀여운 게임이 깔려있다. 지뢰 찾기는 <b>M</b> <i>X</i> <b>N</b> 크기의 지뢰밭에서 모든 지뢰의 위치를 찾아내는 게임이다.

이 게임에서는 각 칸에 인접한 칸에 몇 개의 지뢰가 있는지를 보여준다. 각 칸에는 최대 여덟 개의 인접한 칸이 있을 수 있다. 아래에서 왼쪽에 있는 4 X 4 지뢰밭에는 지뢰 두 개가 있으며 각각은 '<b>*</b>' 문자로 표시되어 있다. 이 지뢰밭을 방금 설명한 힌트 숫자로 표기하면 오른쪽에 있는 것과 같은 필드가 만들어진다.

<img width="330" alt="스크린샷 2020-01-15 23 16 44" src="https://user-images.githubusercontent.com/50854729/72442045-1eb34d00-37ef-11ea-844f-958a1a6cf8d5.png"  >

#### >> 입력

입력은 임의 개수의 지뢰밭으로 구성된다. 각 지뢰밭의 첫번째 줄에는 각각 행과 열의 개수를 나타내는 두 개의 정수 n과 m(0<n, m<=100)이 들어있다. 그 다음 줄부터는 n개의 줄에 걸쳐서 각 줄마다 정확하게 m 지뢰가 없는 칸은 '<b>.</b>'으로, 지뢰는 '*****'로 표시되며 이때 따옴표는 쓰지 않는다. n=m=0인 줄은 입력이 끝났음을 나타내는 것이므로 그 줄은 처리하지 않는다.

#### >> 출력

각 지뢰밭에 대해 Field #x:라고 적혀있는 메시지를 출력한다. 이때 x는 필드 번호를 나타내며 1에서 시작한다. 그 다음 줄부터는 n개의 줄에 걸쳐서 '<b>.</b>' 문자 대신 그 칸에 인접한 칸에 들어있는 지뢰의 개수를 출력한다. 각 지뢰밭에 대한 출력 사이에는 반드시 빈 줄이 하나씩 있어야 한다.

#### >> 결과

<img width="368" alt="스크린샷 2020-01-16 02 01 53" src="https://user-images.githubusercontent.com/50854729/72454530-642e4500-3804-11ea-9137-38b429ff0fbc.png">

<img width="276" alt="스크린샷 2020-01-16 02 02 45" src="https://user-images.githubusercontent.com/50854729/72454538-67293580-3804-11ea-86b9-4c506933569c.png">

<hr>

## 문제 3. 여행(Trip)

일 년에 한 번씩 다른 여행지로 여행을 가는 학생 모임이 있다. 그 학생들은 지금까지 인디애나폴리, 피닉스, 내시빌, 필라델피아, 산호세, 아ㅌㄹ란타를 여행했다. 이번 봄에는 아인트호벤으로 여행갈 계획이다.

이 학생들은 여행 경비를 모두 똑같이 부담하기로 합의했지만 돈을 쓸 때마다 나눠서 내는 것은 별로 실용적이지 못하다. 그래서 한 명씩 식비, 호텔비, 텍시비, 비행기표를 부담하기로 한다. 여행이 끝난 후에 각 학생이 지출한 내역을 계산한 다음 1센트 단위 내에서 모든 학생들이 쓴 돈이 같도록 돈을 주고 받는다. 하지만 이전 여행의 경험에 비추어보면 돈을 주고 받는 과정은 정말 지루하고 오랜 시간을 요하는 작업이었다. 지출 내역이 주어졌을 때 모든 학생이 쓴 돈이 (1센트 단위 내에서) 똑같아지기 위해 전달되어야 하는 최소 액수를 구해보자.

#### >> 입력

표준 입력을 통해 여러 번의 여행에 대한 정보가 입력된다. 각 여행은 여행에 참가한 학생 수를 나타내는 정수 n으로 구성된다. 이 정수 밑으로는 n개의 줄이 입력되는데, 각 줄에는 달러와 센트 단위로 각 학생이 지출한 경비가 입력된다. 학생 수는 1000명을 넘지 않으며 어떤 학생도 $10,000.00 이상 지출하지 않는다. 마지막 여행에 대한 정보 다음 줄에는 0만 들어있는 줄이 입력된다.

#### >> 출력

각 여행에 대해 각 학생이 사용한 금액이 똑같아지기 위해 전달되어야 하는 금액의 총합을 출력한다.

#### >> 결과

<img width="436" alt="스크린샷 2020-01-16 02 05 58" src="https://user-images.githubusercontent.com/50854729/72454757-d141da80-3804-11ea-832a-3976be10690b.png">

<hr>

## 문제 4. LCD 디스플레이(LCD Display)

한 친구가 방금 새 컴퓨터를 샀다. 그 친구가 지금까지 샀던 가장 강력한 컴퓨터는 공학용 전자 계산기였따. 그런데 그 친구는 새 컴퓨터의 모니터보다 공학용 계산기에 있는 LCD 디스플레이가 더 좋다며 크게 실망하고 말았다. 그 친구를 만족시킬 수 있도록 숫자를 LCD 디스플레이 방식으로 출력하는 프로그램을 만들어보자.

#### >> 입력

입력 파일은 여러 줄로 구성되며 표시될 각각의 숫자마다 한 줄씩 입력된다. 각 줄에는 s와 n이라는 두 개의 정수가 들어있으며 n은 출력될 숫자(0<=n<=99,999,999), s는 숫자를 표시하는 크기(1<=s<=10)를 의미한다. 0이 두 개 입력된 줄이 있으면 입력이 종료되며 그 줄은 처리되지 않는다.

#### >> 출력

입력 파일에서 지정한 숫자를 수평 방향은 '-' 기호를, 수직 방향은 '|'를 이용해서 LCD 디스플레이 형태로 출력한다. 각 숫자는 정확하게 s+2개의 열, 2s+3개의 행으로 구성된다. 마지막 숫자를 포함한 모든 숫자를 이루는 공백을 스페이스로 채워야 한다. 두 개의 숫자 사이에는 정확하게 한 열의 공백이 있어야 한다.

각 숫자 다음에는 빈 줄을 한 줄 출력한다 밑에 있는 출력 예에 각 숫자를 출력하는 방식이 나와있다.

#### >> 결과

<img width="362" alt="스크린샷 2020-01-16 02 08 13" src="https://user-images.githubusercontent.com/50854729/72454917-27168280-3805-11ea-8094-9bb5b112613b.png">

<hr>

## 문제 5. 그래픽 편집기(Graphical Editor)

포토샵 같은 그래픽 편집기를 이용하면 텍스트 편집기에서 문서를 수정하는 것처럼 비트맵 이미지를 수정할 수 있다. 이미지는 픽셀로 이루어진 <b>M</b> <i>X</i> <b>N</b> 배열로 표현되며 각 픽셀마다 색이 주어진다.

간단한 대화형 그래픽 편집기 흉내를 낼 수 있는 프로그램을 만들어보자.

#### >> 입력

입력은 한 줄에 하나씩의 편집기 명령으로 구성된다. 각 명령은 줄 맨 앞에 있는 대문자 한 개로 표현된다. 매개변수가 필요한 경우에는 그 명령과 같은 줄에 스페이스로 분리되어 매개변수가 입력된다.

픽셀 좌표는 1 이상 M 이하의 열 번호와 1 이상 N 이하의 행 번호, 이렇게 두 개의 정수로 표현되며 이때 1<=M, N<=250라는 조건이 만족된다. 표의 왼쪽 위 꼭지점을 원점으로 삼는다. 색은 대문자로 지정된다.

편집기에서 받아들이는 명령은 다음과 같다.

<b> I M N :</b> 모든 픽셀이 흰색(O)으로 칠해진 <i>M X N</i> 이미지를 새로 만든다.

<b>C :</b> 모든 픽셀을 흰색(O)으로 칠해서 표를 지운다. 이미지의 크기는 바뀌지 않는다.

<b>L X Y C :</b> (<i>X, Y</i>) 픽셀을 주어진 색(C)으로 칠한다.

<b>V X Y1 Y2 C :</b> <i>X</i> 열에 <i>Y1</i> 행과 <i>Y2</i> 행(<i>Y1, Y2</i> 포함) 사이에 주어진 색(C)으로 수직 방향 직선을 긋는다.

<b>H X1 X2 Y C :</b> <i>Y</i> 행에 <i>X1</i> 열과 <i>X2</i> 행(<i>X1, X2</i>) 사이에 주어진 색(C)으로 수평 방향 직선을 긋는다.

<b>K X1 Y1 X2 Y2 C :</b> 주어진 색(C)으로 채워진 직사각형을 그린다. (<i>X1, Y1</i>)은 왼쪽 위 끝점, (<i>X2, Y2</i>)는 오른쪽 아래 끝 점을 의미한다.

<b>F X Y C :</b> R 영역을 주어진 색(C)으로 채우는데, 영역 R은 다음과 같이 정의된다. (<i>X, Y</i>) 픽셀은 R에 속한다. (<i>X, Y</i>) 픽셀과 색이 같고 R에 포함된 픽셀과 맞닿은 부분이 하나라도 있다면 그 픽셀도 R 영역에 포함된다.

<b>S Name :</b> 파일명은 입력받은 그대로 출력하고 그 뒤에 현재 이미지의 내용을 출력한다.

<b>X :</b> 세션을 종료한다.

#### >> 출력

S NAME이라는 명령이 있을 때마다 NAME으로 주어진 파일명을 출력하고 현재 이미지의 내용을 출력한다. 각 행은 각 픽셀의 색을 나타내는 문자로 표시된다. 출력 예를 참고하자.

I, C, L, V, H, K, F, S, X를 제외한 문자로 정의된 명령이 있으면 그 줄 전체를 무시하고 다음 명령으로 넘어간다. 다른 오류에 대해서는 프로그램의 행동을 예측할 수 없다.

#### >> 결과

<img width="304" alt="스크린샷 2020-01-16 01 18 35" src="https://user-images.githubusercontent.com/50854729/72450804-4d84ef80-37fe-11ea-8774-f52f7e731ade.png">

<img width="351" alt="스크린샷 2020-01-16 01 19 14" src="https://user-images.githubusercontent.com/50854729/72450972-9341b800-37fe-11ea-835d-445d7f9eacc3.png">

<hr>

## 문제 6. 인터프리터(Interpreter)

어떤 컴퓨터에 열 개의 레지스터와 1,000워드 분량의 램(RAM)이 있따. 각 레지스터 또는 램 위치에는 0 이상 999 이하의 세 자리 정수가 저장된다. 명령어는 세 자리 정수로 인코딩되며 램에 저장된다. 인코딩은 다음과 같다.

- 100 : 종료
- 2dn : d 레지스터를 n으로 설정(0이상 9이하)
- 3dn : d 레지스터에 n 더함
- 4dn : d 레지스터에 n 곱함
- 5ds : d 레지스터를 s 레지스터의 값으로 설정
- 6ds : s 레지스터의 값을 d 레지스터에 더함
- 7ds : d 레지스터에 s 레지스터의 값을 곱함
- 8da : d 레지스터를 a 레지스터에 저장된 주소의 램에 들어있는 값으로 설정
- 9sa : a 레지스터에 저장된 주소의 램에 s 레지스터의 값을 대입
- 0ds : s 레지스터에 0이 들어있지 않으면 d 레지스터에 있는 위치로 이동

모든 레지스터의 초기 값은 000이다. 램에 저장되는 초기 값은 표준 입력으로부터 들어온다. 처음으로 실행될 명령은 주소가 0인 램에 들어있다. 모든 결과는 값이 1,000이 넘어가면 1,000으로 나눈 나머지로 줄어든다.

#### >> 입력

입력은 입력 케이스의 개수를 나타내는 양의 정수 한 개가 들어있는 줄로 시작되며 그 줄에는 그 숫자밖에 입력되지 않는다. 그 뒤에는 빈 줄이 하나 들어가고 서로 다른 입력 케이스 사이에는 빈 줄 두 개가 입력된다. 각 입력 케이스는 최대 1,000개의 부호가 없는 세 자리 정수로 구성되며 그 숫자들은 0부터 시작하는 연속된 램 위치에 저장되는 내용을 나타낸다. 값이 지정되지 않는 램 위치는 000으로초기화된다.

#### >> 출력

각 테스트 케이스마다 하나씩의 정수를 출력한다. 출력되는 정수는 종료 명령어에 이르기까지(종료 명령어 포함) 실행된 명령어의 개수다. 프로그램이 종료된다고 미리 가정해도 된다. 케이스가 여러 개 있는 경우에는 각 출력 사이에 빈 줄을 출력한다.

#### >> 결과

<img width="426" alt="스크린샷 2020-01-17 01 26 29" src="https://user-images.githubusercontent.com/50854729/72543040-7671b700-38c8-11ea-9fb3-681bfef2aa98.png">

<hr>

## 문제 7. 체크 확인(Check the Check)

체스판 설정을 읽어서 킹이 공격받고 있는지(체크 상태인지) 확인하는 일을 해야 한다. 상대방의 다음 수에 의해 킹이 죽을 수 있는 위치에 있으면 킹이 체크 상태가 된다.

흰 말은 대문자로, 검은 말은 소문자로 표시된다. 흰 편은 항상 판의 아래쪽에, 검은 편은 판의 위쪽에 자리잡는다.

체스를 잘 모르는 사람들을 위해 각 말의 이동 방법을 설명하자면 다음과 같다.

* <b>폰(Pawn, p 또는 P) :</b> 한 번에 한 칸씩 앞으로만 갈 수 있다. 하지만 대각선에 있는 상대 말을 잡을 수 있으며 이 문제에서 이 부분에 주의해야 한다.

* <b>나이트(Knight, n 또는 N) :</b> 아래에 나와있는 것처럼 L자 모양으로 움직일 수 있다. 다른 말을 뛰어넘을 수 있는 유일한 말이다.

* <b>비숍(Bishop, b 또는 B) :</b> 대각선 방향으로 어느 쪽으로든 이동 거리에 제한을 받지 않고 움직일 수 있다.

* <b>룩(Rook, r 또는 R) :</b> 수직 또는 수평 방향으로 이동 거리에 제한을 받지 않고 움직일 수 있다.

* <b>퀸(Queen, q 또는 Q) :</b> 수직, 수평, 대각선 방향으로 어느 쪽으로든 이동 거리에 제한을 받지 않고 움직일 수 있다.

* <b>킹(King, k 또는 K) :</b> 수직, 수평, 대각선 방향으로 어느 쪽으로든 한 칸을 움직일 수 있다.

다른 말을 건너뛸 수 있는 것은 나이트밖에 없다는 것을 꼭 기억해두자. 폰의 움직임은 어느 편인가에 따라 다르다. 검은 폰이면 아래쪽 대각선 방향으로, 흰색 폰이면 위쪽 대각선 방향으로 한 칸만 움직일 수 있다. 위에 있는 예는 소문자 "p"로 표시된 검은 폰의 움직임을 나타낸 것이다. 방금 "움직인다"라고 표현한 것은 폰이 상대방 말을 잡을 수 있는 경우를 의미한다.

#### >> 입력

입력에는 임의 개수의 체스판 배치가 들어있을 수 있으며 각 판은 각각 여덟 개 문자로 구성된 여덟 줄로 구성된다. "<b>.</b>"은 빈 칸을 의미하며 위에서 정의했듯이 각 말을 의미하는 대문자 또는 소문자가 입력된다. 틀린 문자는 없으며 두 킹이 모두 체크를 당하는 배치는 입력되지 않는다. "<b>.</b>" 문자만으로 구성된 비어있는 체스판이 나올 때까지 입력을 읽어야 하며 비어있는 체스판은 처리하지 않는다. 각 체스판 배치 사이에는 빈 줄이 하나씩 들어간다. 비어있는 판을 제외한 모든 판에는 정확하게 하나씩의 흰 킹과 검은 킹이 들어있다.

#### >> 출력

입력된 각 판 배치에 대해 다음 중 한가지 답을 출력한다.

* Game #<i>d</i>: white king is in check.

* Game #<i>d</i>: black king is in check.

* Game #<i>d</i>: no king is in check.

여기에서 <i>d</i>는 1에서 시작하는 게임 번호를 나타낸다.

#### >> 결과

<img width="335" alt="스크린샷 2020-01-16 01 48 55" src="https://user-images.githubusercontent.com/50854729/72453634-c25a2880-3802-11ea-8db0-0a30f6ba961f.png">

<img width="279" alt="스크린샷 2020-01-16 01 49 48" src="https://user-images.githubusercontent.com/50854729/72453650-c9813680-3802-11ea-918e-153361dcd4c7.png">

<img width="301" alt="스크린샷 2020-01-16 01 51 14" src="https://user-images.githubusercontent.com/50854729/72453665-d00fae00-3802-11ea-82de-805617c3d4f3.png">

<hr>

## 문제 8. 호주실 투표법(AUstralian Voting)

호주식 투표 제도에서는 투표권자가 모든 후보에 대해 선호도 순으로 순위를 매긴다. 처음에는 1순위로 선택한 것만 집계하며 한 후보가 50% 초과 득표하면 그 후보가 바로 선출된다. 하지만 50% 초과 득표한 후보가 없으면 가장 적은 표를 받은 후보(둘 이상이 될 수도 있음)가 우선 탈락된다. 그리고 이렇게 탈락된 후보를 1순위로 찍었던 표만 다시 집계하여 아직 탈락되지 않은 후보들 가운데 가장 높은 선호도를 얻는 후보가 그 표를 얻는다. 이런 식으로 가장 약한 후보들을 탈락시키면서 그 다음 순위의 아직 탈락하지 않은 후보에게 표를 주는 과정을 50%가 넘는 표를 얻는 후보가 나오거나 탈락되지 않은 후보가 동률이 될 때까지 반복한다.

#### >> 입력

입력 케이스의 개수를 나타내는 양의 정수 한 개가 들어있는 행으로 시작되며 그 줄에는 그 숫자밖에 입력되지 않는다. 그 뒤에는 빈 줄이 하나 들어가고 서로 다른 입력 케이스 사이에는 두 개의 빈 줄이 입력된다. 각 케이스의 첫번째 줄에는 후보 수를 나타내는 20 이하의 정수 n이 입력된다. 그 밑으로 n개의 줄에 걸쳐서 후보의 이름이 순서댈 입력되며 각 후보의 이름은 80글자 이하로, 출력 가능한 문자로 구성된다. 그 뒤에는 최대 1,000줄이 입력될 수 있는데, 각 줄에는 투표 내역이 입력된다. 각 투표 내역에는 어떤 순서로 1부터 n까지의 수가 입력된다. 첫번째 숫자는 1순위로 찍은 후보의 번호, 두번째 숫자는 2순위로 찍은 후보의 번호, 이런 식으로 숫자가 기록된다.

#### >> 출력

각 테스트 케이스에 대해 당선된 후보의 이름 한 줄, 또는 동률을 이룬 후보들의 이름이 들어있는 여러 줄을 출력한다 두 개 이상의 테스트 케이스가 있는 경우 각 결과는 한 개의 빈 줄로 구분한다.

#### >> 결과

<img width="337" alt="스크린샷 2020-01-16 19 09 49" src="https://user-images.githubusercontent.com/50854729/72515844-f5003180-3893-11ea-915d-41039299e3a4.png">



